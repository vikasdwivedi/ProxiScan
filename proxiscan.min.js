/*
* Copyright (c) 2024 Vikas Dwivedi
* Licensed under the MIT license
*/
(function(global){const ProxiScan={};function validateDataset(dataset,dimensions){if(!Array.isArray(dataset)||dataset.length===0){throw new Error("Invalid dataset: must be a non-empty array.")}dataset.forEach(point=>{if(!Array.isArray(point)||point.length!==dimensions){throw new Error(`Invalid dataset: each point must have ${dimensions} coordinates.`)}})}function calculateDistance2D(point1,point2){return Math.sqrt(Math.pow(point2[0]-point1[0],2)+Math.pow(point2[1]-point1[1],2))}function calculateDistance3D(point1,point2){return Math.sqrt(Math.pow(point2[0]-point1[0],2)+Math.pow(point2[1]-point1[1],2)+Math.pow(point2[2]-point1[2],2))}function mergeMasterDatasets(masterDatasets,scanRadius,dimensions,acceptancePercentage){const mergedMasterDataset=[];const pointOccurrences=new Map;const calculateDistance=dimensions===3?calculateDistance3D:calculateDistance2D;const totalDatasets=masterDatasets.length;const acceptanceThreshold=Math.ceil(acceptancePercentage/100*totalDatasets);masterDatasets.forEach(dataset=>{dataset.forEach(point1=>{let foundSimilar=false;for(let[existingPoint,count]of pointOccurrences){let distance=calculateDistance(existingPoint,point1);if(distance<=scanRadius){pointOccurrences.set(existingPoint,count+1);foundSimilar=true;break}}if(!foundSimilar){pointOccurrences.set(point1,1)}})});for(let[point,count]of pointOccurrences){if(count>=acceptanceThreshold){mergedMasterDataset.push(point)}}return mergedMasterDataset}ProxiScan.calculateMultiMasterDatasetSimilarity=function(masterDatasets,testDatasets,scanRadius,dimensions=2,useAndCondition=true,acceptancePercentage=100){masterDatasets.forEach(dataset=>validateDataset(dataset,dimensions));const finalMasterDataset=mergeMasterDatasets(masterDatasets,scanRadius,dimensions,acceptancePercentage);testDatasets.forEach(testDataset=>validateDataset(testDataset,dimensions));let matchedPoints=0;let matchedPairs=[];const calculateDistance=dimensions===3?calculateDistance3D:calculateDistance2D;finalMasterDataset.forEach(masterPoint=>{let pointMatches=[];let matchFound=useAndCondition;for(let datasetIndex=0;datasetIndex<testDatasets.length;datasetIndex++){let testDataset=testDatasets[datasetIndex];let matchedInDataset=false;for(let i=0;i<testDataset.length;i++){let testPoint=testDataset[i];let distance=calculateDistance(masterPoint,testPoint);if(distance<=scanRadius){pointMatches.push({datasetIndex:datasetIndex,testPoint:testPoint});matchedInDataset=true;break}}if(useAndCondition){if(!matchedInDataset){matchFound=false;break}}else{if(matchedInDataset){matchFound=true;break}}}if(matchFound){matchedPoints++;matchedPairs.push({masterPoint:masterPoint,matches:pointMatches.map(match=>({testDatasetIndex:match.datasetIndex,testPoint:match.testPoint}))})}});const maxPoints=finalMasterDataset.length;const similarityScore=matchedPoints/maxPoints;return{matchedPoints:matchedPoints,totalPoints:maxPoints,similarityScore:similarityScore,matchedPairs:matchedPairs}};global.ProxiScan=ProxiScan})(typeof window!=="undefined"?window:global);